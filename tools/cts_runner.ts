import { DOMParser } from "https://deno.land/x/deno_dom@v0.1.21-alpha/deno-dom-wasm.ts";

const CTS_PATH = new URL(
  "../WebGL/conformance-suites/2.0.0/conformance2/00_test_list.txt",
  import.meta.url,
);

const DENO_GL_IMPORT = new URL("../mod.ts", import.meta.url).toString();

async function* getTests(path: URL): AsyncIterableIterator<URL> {
  const testList = await Deno.readTextFile(path);
  for (const line of testList.replaceAll("\r\n", "\n").split("\n")) {
    if (line.startsWith("//")) continue;
    const entry = line.split(" ").pop()!;
    if (entry.endsWith(".txt")) {
      for await (const url of getTests(new URL("./" + entry, path))) {
        yield url;
      }
    } else if (entry.endsWith(".html")) {
      yield new URL("./" + entry, path);
    }
  }
}

Deno.test("WebGL CTS", async (t) => {
  const groups = new Map<string, Set<[string, URL]>>();

  for await (const test of getTests(CTS_PATH)) {
    let name = test.href.split("conformance2/").pop()!;
    name = name.substring(0, name.length - 5);

    const [groupName, ...parts] = name.split("/");
    const group = groups.get(groupName) ?? new Set();
    group.add([parts.join("/"), test]);
    groups.set(groupName, group);
  }

  const parser = new DOMParser();
  const importCache = new Map<string, string>();

  async function tryImport(url: URL) {
    const exists = importCache.get(url.toString());
    if (exists) return exists;
    const code = await Deno.readTextFile(url);
    importCache.set(url.toString(), code);
    return code;
  }

  await Deno.remove(new URL("./test", import.meta.url), { recursive: true })
    .catch(() => {});
  await Deno.mkdir(new URL("./test", import.meta.url));

  for (const [group, tests] of groups) {
    if (Deno.args.length !== 0 && !Deno.args.includes(group)) {
      continue;
    }

    await t.step(group, async (t) => {
      for (const [name, url] of tests) {
        await t.step(name, async () => {
          const html = await Deno.readTextFile(url);
          const document = parser.parseFromString(html, "text/html")!;
          let code = "// NOTE: Auto-generated by Deno GL CTS runner\n\n";

          code += `import "${DENO_GL_IMPORT}";\n\n`;

          code += `globalThis.LOCATION = new URL(${JSON.stringify(url.href)});\n`;
          code += `globalThis.HEADLESS = true;\n`;
          code += `globalThis.EXIT_CODE = 0;\n`;
          code += "globalThis.parent = {};\n";
          code += `globalThis.parent.webglTestHarness = {};`;
          code += `globalThis.parent.webglTestHarness.reportResults = (path, success, msg, skipped = false) => {\n`;
          code += `  if (!success && !skipped) {\n`;
          code += `    console.error("Test failed!");\n`;
          code += `    console.error("Path:", path);\n`;
          code += `    console.error("Message:", msg);\n`;
          code += `    Deno.exit(1);\n`;
          code += `  }\n`;
          code += "};\n";
          code += `globalThis.parent.webglTestHarness.notifyFinished = (path) => {\n`;
          code += `  Deno.exit(globalThis.EXIT_CODE);\n`;
          code += "};\n";
          code += "\n";

          const shaders = new Map<string, {
            type: string;
            source: string;
          }>();
          const scripts = new Map<string, string>();

          let anonID = 0;

          for (const node of document.getElementsByTagName("script")) {
            const src = node.getAttribute("src");
            const type = node.getAttribute("type");

            if (type?.startsWith("x-shader")) {
              shaders.set(node.id, {
                type: type!,
                source: node.textContent,
              });
            } else if (src) {
              const srcUrl = new URL(src, url);
              scripts.set(srcUrl.toString(), await tryImport(srcUrl));
            } else {
              scripts.set("anon-script-tag-" + anonID, node.textContent);
              anonID++;
            }
          }

          const canvas = document.getElementsByTagName("canvas")[0];
          if (canvas) {
            code += "\n";
            code += `window.innerWidth = ${canvas.getAttribute("width")};\n`;
            code += `window.innerHeight = ${canvas.getAttribute("height")};\n`;
            code += "\n";
          }

          code += "//#region Shaders\n\n";

          code += "globalThis.CTS_SHADERS = new Map();\n\n";

          for (const [name, shader] of shaders) {
            code += `CTS_SHADERS.set("${name}", {\n`;
            code += `  type: "${shader.type}",\n`;
            code += `  source: ` + JSON.stringify(shader.source) + `,\n`;
            code += "});\n\n";
          }

          code += "//#endregion\n\n";

          for (const [path, source] of scripts) {
            code += `//#region Script: ${path}\n\n`;
            code += source.trim();
            code += `\n\n//#endregion\n\n`;
          }

          code = code.trim() + "\n";

          code = code.replaceAll("\n}());\n", "\n}).bind(globalThis)();\n");
          code = code.replaceAll("window.location", "globalThis.LOCATION");
          code = code.replaceAll(
            `opt_canvas = opt_canvas || document.createElement("canvas");`,
            `opt_canvas = document.createElement("canvas");`,
          );

          const codeURL = new URL("./test/" + name + ".js", import.meta.url);
          await Deno.writeTextFile(
            codeURL,
            code,
          );

          const result = await Deno.run({
            cmd: [
              "deno",
              "run",
              "-A",
              "--unstable",
              "--no-check",
              codeURL.toString(),
            ],
            stdin: "null",
            stdout: "piped",
            stderr: "piped",
          });

          const status = await result.status();

          const stdout = new TextDecoder().decode(await result.output()).trim();
          const stderr = new TextDecoder().decode(await result.stderrOutput()).trim();

          result.close();

          if (stdout) {
            console.log(`\n${stdout}`);
          }

          if (stderr) {
            console.error(`\n${stderr}`);
          }

          if (!status.success) {
            throw new Error(
              `Test ${name} failed with exit code ${status.code}`,
            );
          }
        });
      }
    });
  }
});
